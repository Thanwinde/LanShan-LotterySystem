# 蓝山抽奖系统

---

一个通用的抽奖系统，高度可定制化，性能优秀，可靠性强

---

## 技术栈

+ Sentinel 提供全局限流+用户限流，防止脚本/频繁调用冲垮服务
+ Nacos 提供限流配置拉取，支持热更新限流规则
+ Redis 提供缓存保护，防止缓存雪崩，穿透，击穿，同时使用管道来高效处理奖品导入
+ MySQL 作为数据库，采用主从复制，实现读写分离来提高性能
+ Quartz 实现定时任务，定时开启/关闭抽奖，使用MySQL持久化，宕机后也能补偿执行结束/开始任务
+ Hashids 来将密码转化为一个短小不可预测但可还原的字符串哈希来支持密码抽奖
+ 采用RebbitMQ来异步持久化抽奖记录，采用阻塞队列 + 批处理高效处理抽奖时的大量记录，防止冲垮MySQL
+ 使用JWT + 自定义过滤器来实现鉴权，轻量高效，支持集群
+ ~~使用QQ OAuth2 来登录~~ QQ目前申请还没过
+ 采用Lua脚本来解决对于高并发下的各种数据不一致，实现抽奖的原子操作

---

## 项目亮点

+ 高性能：经过tomcat调优以及各种优化，在**单个tomcat**下的情况下QPS可以达到**800 -1500**左右，可以承受一秒内**12000**的突发流量无拒绝连接且无异常 在Windows下占用内存6G,tomcat2G,系统4G，CPU占用约20% - 50%，8核 3.2Hz,如果能换成Linux + tomcat集群+Nacos负载均衡完全可以达到更高的QPS
+ 原子性：采用Lua脚本来实现大部分抽奖逻辑，实现了原子化操作，避免了高并发带来的一系列数据不一致问题，同时采用redis来处理抽奖逻辑极大的提升了速度
+ 高速缓存：封装了Redis缓存工具，可以高效率的建立缓存，批量查询，缓存，极大的提升速度以及用户体验
+ 细致的限流机制：拥有用户为单位的全局限流，防止恶意访问，对于一些接口都有单独的特殊限制：比如抽奖接口QPS会高一些，查询全部抽奖记录QPS会低一些
+ 支持抽奖的高度自定义：在新增抽奖时可以设置没人抽奖次数，参加者，黑名单者以及每个人的中奖权重：权重越高者越有概率触发“重掷”，获得更稀有的奖品，同样的，黑名单者一定会触发“重掷”，不过是会获得更低一级的奖品。可以设置是否即抽即中，或是定时开奖
+ 支持密码抽奖：用户需要输入密码才能抽奖，本质上是把抽奖编号用Hashids转化为一个短小不可预测但可还原的字符串哈希而非对称加密，使用其来抽奖会将其快速的解密为抽奖id来尝试抽奖，对性能损耗极少
+ 支持对抽奖进行管理，查看，导出：可以在抽奖开始前修改抽奖配置，也可以在中途强行停止抽奖（结果也会保存），可以查看每个抽奖的信息、中奖记录，自己的抽奖记录等，且进行了数据可见处理：黑名单，权重等数据不会给除了创建者之外其他人看到。同时支持把抽奖记录通过excel导出
+ 支持热更新限流：支持从Nacos/Sentinel dashboard动态更新限流规则，在高压环境下可提高其他接口的限流来供给更多资源给抽奖服务
+ ~~使用QQ进行OAuth2登录,便于用户快速注册，立即通过二维码等方法进行快速抽奖~~ （QQ申请还没过）
+ 多重抽奖数据保障：假如抽奖中宕机，重启后会补偿性的终止抽奖（假如已结束），开始抽奖同理。同时，正在处理的抽奖会根据自己所处的阶段有不同的恢复方式：
+ 还未进入数据库：抽奖次数，结果也未修改，无影响
+ Redis阶段：Redis Lua在扣减库存前会也写入一份抽奖记录在Redis中，后续可以人工去恢复
+ MQ阶段：会在队列中存在，上线后继续消费
+ 死信阶段：如果一个消息三次消费都抛异常，那就会进入死信机记录在日志中，后续人工核查

---

## 具体实现:

### 抽奖：

在开始抽奖时，会按照奖品数将奖品加入reids中（使用管道，速度极快），抽奖会调用lua脚本： SPOP随机弹出一个作为结果：如果用户触发了重掷会在Lua中再次SPOP取高/低者，随后返回加入消息队列，每200ms或队列容量达到500便会一次发给MySQL避免频繁建立连接，根据是即抽即中还是定时开奖来设定其是否可见（获取记录的接口只能获取设为可见的抽奖记录）

### 限流:

主要采用Sentinel的热点参数限流，参数为用户的userId，除了抽奖的接口不会经过全局限流外，其他接口会先经过全局限流再根据其url特殊限流（如果有）

比如针对新增抽奖，就会先进入全局限流（10QPS），再进入对新增抽奖的单独限流（2QPS）

### 优化：

tomcat调优：使用 NIO / NIO2/ HTTP/1.1 分别测试，测出其中表现最优异者使用，增加线程数，内存以及队列长度等

MySQL调优：部署集群，实现读写分离，为id，creator等热点字段建立索引,大量上传采用批处理等

Redis调优：尽可能的采用批处理，对于像是开启抽奖时的大量导入数据采用管道来处理等

缓存处理：对于绝大多数数据采用缓存，对于经常变化的数据设置较短的过期时间，同时在过期时间上加上一个随机数，查询不到的数据返回空缓存，建立缓存时会加上一个互斥锁，来在加速访问的同时避免缓存击穿，穿透以及雪崩

---

